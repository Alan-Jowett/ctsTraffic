# TCP-style 3-Way Handshake Plan for Media Stream (Receiver-init)

This document describes how to change the media stream protocol from the existing single-frame (one-way) `START` handshake into a TCP-style 3-way handshake initiated by the receiver. The plan includes the exact handshake, suggested frame formats, state machines, migration guidance (because the codebase currently supports a 1-way START), tests, and rollout steps.

## Goals

- Implement a robust 3-way handshake so the receiver reliably negotiates stream parameters and confirms readiness before the sender transmits media.
- Keep backward compatibility with existing one-way START behavior during rollout.
- Add tests, logging, and feature gating to allow staged deployment.

## Handshake overview

- Step 1 (SYN / START): Receiver -> Sender
  - The receiver sends a `START` (SYN) frame containing requested stream parameters and a `StreamId` / `Nonce`.
- Step 2 (SYN-ACK / START_ACK): Sender -> Receiver
  - The sender validates the request, reserves resources, responds with `START_ACK` including accepted parameters and `StreamId` echo (and a `SenderNonce` if needed).
- Step 3 (ACK): Receiver -> Sender
  - The receiver acknowledges `START_ACK` with `START_CONFIRM` (ACK). After this, the sender begins streaming media.

Notes:
- The naming `START`, `START_ACK`, `START_CONFIRM` is suggested and can be mapped to existing frame enums.
- `START_ACK` can include a flag indicating whether the sender will begin immediately or wait for `START_CONFIRM` — use this to support faster modes if desired.

## Suggested frame fields

- Common fields for each control frame:
  - `FrameType` (enum): `START`, `START_ACK`, `START_CONFIRM`, `ERROR`.
  - `Version`: protocol version for negotiation.
  - `StreamId`: unique identifier generated by the receiver (GUID or 64-bit).
  - `Nonce` / `SenderNonce`: optional anti-replay or correlation values.
  - `Flags`: bitflags for options (e.g., `ACK_REQUIRED`, `COMPAT_MODE`).
  - `Payload`: optional structured TLV for parameters (frame rate, bit rate, buffer depth, codec hints).

## Code locations to inspect and update

- `ctsTraffic/ctsMediaStreamProtocol.*` — frame definitions and serialization routines.
- `ctsTraffic/ctsMediaStreamReceiver.*` — construct and send `START` and `START_CONFIRM`.
- `ctsTraffic/ctsMediaStreamSender.*` — receive `START`, send `START_ACK`, and begin streaming after `START_CONFIRM`.
- `ctsTraffic/ctsMediaStreamServerListeningSocket.*` — any server glue that wires frames to sockets.
- `ctsTraffic/ctsMediaStream*.h` — state enums and shared data structures.

Search for existing one-way START handling (strings: `START`, `Start`, `FrameType`, `StreamStart`) to find the exact current locations.

## Step-by-step implementation plan

1) Review existing 1-way START implementation
   - Locate the code that builds and sends the current `START` frame and where senders consume it.
   - Identify any implicit assumptions (sender immediately streams on receiving START, no ACK expected).

2) Define new frame types and wire serialization
   - Add `START_ACK` and `START_CONFIRM` to the `FrameType` enum in `ctsMediaStreamProtocol`.
   - Define TLV or fixed-field layout for the frames and implement (de)serialization functions.

3) Extend state machines
   - Sender states: `Idle` -> `PendingStartRequest` -> `PendingConfirm` -> `Streaming` -> `Closed`.
   - Receiver states: `ReadyToStart` -> `AwaitingStartAck` -> `AwaitingStartConfirm` (if needed) -> `Streaming` -> `Closed`.

4) Implement sender behavior
   - On `START`:
     - Validate `Version` and parameters.
     - Allocate/reserve resources (buffers, encoders, scheduling).
     - Reply with `START_ACK` including accepted parameters and `SenderNonce`.
     - Move to `PendingConfirm` state.
   - On `START_CONFIRM`:
     - Verify `StreamId`/nonces match and transition to `Streaming`.
     - Begin normal media sends.
   - On invalid parameters or resource failures, reply with `ERROR` frame and go to `Closed`.

5) Implement receiver behavior
   - When ready, build `START` with `StreamId` and desired parameters and send it.
   - Move to `AwaitingStartAck`; start timeout/retry timer.
   - On `START_ACK` from sender:
     - Validate accepted parameters.
     - Optionally adjust local parameters to match accepted ones.
     - Send `START_CONFIRM` (ACK) and move to `Streaming`.
   - If `START_ACK` not received within retry limits, mark error and abort.

6) Backward compatibility and negotiation
   - Add a `COMPAT_MODE` flag or `Version` negotiation:
     - If the sender does not recognize `START` (old build), it will ignore it; receiver should detect lack of response and fall back to prior behavior (e.g., allow sender to initiate or use existing mechanism).
     - Alternatively, implement a feature flag in `ctsConfig` to enable the 3-way handshake.

7) Timeouts, retries, and error codes
   - Define reasonable timeouts (e.g., 500ms - 2s) and exponential backoff for `START` retries.
   - Define retry counts (e.g., 3 attempts) and clear error codes for `ERROR` frames.

8) Tests
   - Unit tests for frame (de)serialization and edge cases.
   - Sender unit tests for state transitions on `START`, `START_ACK`, `START_CONFIRM` and on error frames.
   - Receiver unit tests for retry logic and failure modes.
   - Integration tests: two-process tests where a receiver initiates START and sender accepts.
   - Regression tests: verify that the legacy one-way START still works when compatibility mode is active.

9) Instrumentation
   - Add logging at state transitions and for frame send/receive events.
   - Counters/metrics for attempts, successes, failures, time-to-stream.

10) Feature flag and rollout
   - Implement a runtime feature flag (in `ctsConfig`) to enable the 3-way handshake.
   - Run unit and integration tests locally; run CI.
   - Canary deploy to a small subset of hosts; monitor metrics.
   - Gradually increase rollout and remove the flag after confirmed stability.

## Migration from one-way START (the current code)

- Because the repo currently uses a one-way START frame, plan a two-stage migration:
  1. Add new frame types and handlers while preserving existing behavior as the default.
  2. Add a runtime config flag to enable the 3-way handshake in test environments.
  3. Once validated, flip the default to 3-way and remove legacy paths after a suitable deprecation period.

Make sure the receiver's `START` includes a `COMPAT_MODE` bit so a modern sender can indicate if it accepts 3-way behavior.

## Example pseudo-code

Receiver (initiator):

```
start_stream():
  sid = generateStreamId()
  start = build_frame(START, {version, sid, params, flags})
  send(start)
  state = AwaitingStartAck
  wait(timeout)
  if receive(START_ACK):
    validate()
    send(build_frame(START_CONFIRM, {sid}))
    state = Streaming
  else if retries_exhausted:
    fallback_or_fail()
```

Sender (responder):

```
on_receive(frame):
  if frame.type == START:
    if validate_and_can_allocate(frame.params):
      reserve_resources()
      send(build_frame(START_ACK, {version, sid=frame.sid, accepted_params, senderNonce}))
      state = PendingConfirm
    else:
      send(build_frame(ERROR, {code}))
  else if frame.type == START_CONFIRM and state == PendingConfirm:
    if match_sid_and_nonce(frame):
      state = Streaming
      begin_media_send()
```

## Manual test checklist

- Build and run sender and receiver locally with the feature flag enabled.
- Confirm via logs or packet capture the 3-way handshake sequence: `START` -> `START_ACK` -> `START_CONFIRM`.
- Verify the sender does not send media before `START_CONFIRM`.
- Test negative cases: malformed `START`, `START_ACK` with mismatched `StreamId`, and ensure proper `ERROR` frames and teardown.
- Verify fallback to one-way behavior when communicating with an older sender.

## Acceptance criteria

- The 3-way handshake completes reliably in normal network conditions.
- Sender does not transmit media before receiving `START_CONFIRM`.
- Tests cover positive and negative scenarios; rollback is possible via feature flag.
- Backward compatibility is demonstrated or a clear migration path is documented.

---

If you'd like, I can now scan the repository to find the exact files and functions to update, then prepare a concrete patch that adds the new frame types and skeleton state-machine changes behind a feature flag.
